#!/usr/bin/env bash

# Validate GEM++ Docker CLI behaviour against the expectations encoded
# in a metadata.json file describing graph pairs.
#
# The script runs the `gempp-cli` Docker image (or a user-supplied image)
# for every pair listed in the metadata, requests an exact subgraph search,
# and compares the solver outcome with the declared relationship
# (isomorphic / non-isomorphic / subgraph-isomorphic / not subgraph-isomorphic).
#
# Usage:
#   ./tools/test_docker_against_metadata.sh [--image IMAGE] [--keep-solutions] [metadata.json]
#   IMAGE             Docker image to run (default: gempp-cli or $GEMPP_CLI_IMAGE).
#   --keep-solutions  Keep *.sol files generated by GEM++; removed otherwise.
#   metadata.json     Optional path to the metadata file. Defaults to the
#                     unlabeled examples metadata shipped with the repository.
#
# Environment:
#   GEMPP_CLI_IMAGE   Overrides the default Docker image name.
#   PYTHON            Choose the Python interpreter (defaults to python3, falls back to python).
#
# Exit codes:
#   0  All pairs match the expectation.
#   1  At least one pair produced an unexpected result or a runtime error occurred.

set -uo pipefail

usage() {
    cat <<'EOF'
Usage: test_docker_against_metadata.sh [OPTIONS] [metadata.json]

Options:
  --image IMAGE        Docker image to run (default: gempp-cli or $GEMPP_CLI_IMAGE)
  --keep-solutions     Keep solution files (*.sol) generated by GEM++
  -h, --help           Show this help message

Arguments:
  metadata.json        Path to metadata file (defaults to unlabeled example metadata)
EOF
}

fatal() {
    echo "Error: $1" >&2
    exit 1
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
DEFAULT_METADATA="$ROOT_DIR/ressources/examples/graph_isomorphism/unlabelled/metadata.json"

IMAGE="${GEMPP_CLI_IMAGE:-gempp-cli}"
KEEP_SOLUTIONS=0
PYTHON_BIN="${PYTHON:-python3}"
METADATA_PATH="$DEFAULT_METADATA"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --image)
            [[ $# -ge 2 ]] || fatal "--image requires a value"
            IMAGE="$2"
            shift 2
            ;;
        --keep-solutions)
            KEEP_SOLUTIONS=1
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            fatal "Unknown option '$1'"
            ;;
        *)
            if [[ "$METADATA_PATH" != "$DEFAULT_METADATA" ]]; then
                fatal "Multiple metadata paths supplied"
            fi
            METADATA_PATH="$1"
            shift
            ;;
    esac
done

[[ $# -eq 0 ]] || fatal "Unexpected positional arguments: $*"

if ! command -v docker >/dev/null 2>&1; then
    fatal "docker command not found in PATH"
fi

if ! command -v "$PYTHON_BIN" >/dev/null 2>&1; then
    if command -v python >/dev/null 2>&1; then
        PYTHON_BIN="python"
    else
        fatal "Python interpreter not found (tried: ${PYTHON_BIN}, python)"
    fi
fi

if [[ ! -f "$METADATA_PATH" ]]; then
    fatal "Metadata file not found: $METADATA_PATH"
fi

METADATA_ABS="$("$PYTHON_BIN" - <<'PY' "$METADATA_PATH"
import os, sys
print(os.path.abspath(sys.argv[1]))
PY
)"

BASE_DIR="$(cd "$(dirname "$METADATA_ABS")" && pwd)"

if ! docker image inspect "$IMAGE" >/dev/null 2>&1; then
    echo "Warning: Docker image '$IMAGE' not found locally. The first run may take longer if the image needs to be pulled or built." >&2
fi

declare -a FAILURES=()
TOTAL=0
PASSED=0

PAIR_STREAM="$("$PYTHON_BIN" - <<'PY' "$METADATA_ABS"
import json
import sys

metadata_path = sys.argv[1]
with open(metadata_path, "r", encoding="utf-8") as handle:
    metadata = json.load(handle)

pairs = metadata.get("pairs", [])
for pair in pairs:
    pair_id = pair.get("id")
    pair_type = pair.get("type")
    pattern = pair.get("pattern")
    target = pair.get("target")
    if None in (pair_id, pair_type, pattern, target):
        raise SystemExit(f"Invalid metadata entry: {pair}")
    print(f"{pair_id}\t{pair_type}\t{pattern}\t{target}")
PY
)"

if [[ -z "$PAIR_STREAM" ]]; then
    fatal "No graph pairs found in metadata: $METADATA_ABS"
fi

while IFS=$'\t' read -r pair_id pair_type pattern_path target_path; do
    [[ -z "$pair_id" ]] && continue
    TOTAL=$((TOTAL + 1))

    pattern_file="$BASE_DIR/$pattern_path"
    target_file="$BASE_DIR/$target_path"

    if [[ ! -f "$pattern_file" ]]; then
        FAILURES+=("[$pair_id] Missing pattern file: $pattern_path")
        echo "[$pair_id] FAIL - missing pattern file: $pattern_path"
        continue
    fi
    if [[ ! -f "$target_file" ]]; then
        FAILURES+=("[$pair_id] Missing target file: $target_path")
        echo "[$pair_id] FAIL - missing target file: $target_path"
        continue
    fi

    pattern_stub="$(basename "${pattern_path%.*}")"
    target_stub="$(basename "${target_path%.*}")"
    solution_file="$BASE_DIR/${pattern_stub}_${target_stub}.sol"

    rm -f "$solution_file"

    if ! docker run --rm \
        -v "$BASE_DIR":/data \
        -w /data \
        "$IMAGE" \
        sub --solver GLPK -t e -O "$pattern_path" "$target_path" \
        >/dev/null; then
        FAILURES+=("[$pair_id] Docker command failed")
        echo "[$pair_id] FAIL - docker run exited with error"
        continue
    fi

    if [[ ! -f "$solution_file" ]]; then
        FAILURES+=("[$pair_id] Expected solution file was not produced")
        echo "[$pair_id] FAIL - solution file missing"
        continue
    fi

    status_output="$("$PYTHON_BIN" - <<'PY' "$solution_file"
import sys
import xml.etree.ElementTree as ET

path = sys.argv[1]
try:
    root = ET.parse(path).getroot()
except ET.ParseError as exc:
    print(f"PARSE_ERROR {exc}")
    sys.exit(1)

objective = root.find(".//objective")
if objective is None:
    print("PARSE_ERROR objective element missing")
    sys.exit(1)

status = objective.attrib.get("status", "").replace(" ", "_")
value = objective.attrib.get("value", "")
print(f"{status} {value}")
PY
)"
    py_status=$?
    status=""
    value=""
    if [[ $py_status -ne 0 ]]; then
        FAILURES+=("[$pair_id] Could not parse solution XML")
        echo "[$pair_id] FAIL - could not parse solution file"
        [[ $KEEP_SOLUTIONS -eq 0 ]] && rm -f "$solution_file"
        continue
    fi

    read -r status value <<<"$status_output"

    expect_match=0
    case "$pair_type" in
        isomorphic|subgraph_isomorphic)
            expect_match=1
            ;;
        non-isomorphic|not_subgraph_isomorphic)
            expect_match=0
            ;;
        *)
            FAILURES+=("[$pair_id] Unsupported pair type '$pair_type'")
            echo "[$pair_id] FAIL - unsupported pair type '$pair_type'"
            [[ $KEEP_SOLUTIONS -eq 0 ]] && rm -f "$solution_file"
            continue
    esac

    match_detected=1
    if [[ "$value" == "inf" || -z "$value" ]]; then
        match_detected=0
    fi

    if (( expect_match == match_detected )); then
        PASSED=$((PASSED + 1))
        echo "[$pair_id] PASS - status=$status value=$value (expected $( (( expect_match )) && printf 'match' || printf 'no match'))"
        if [[ $KEEP_SOLUTIONS -eq 0 ]]; then
            rm -f "$solution_file"
        fi
    else
        if (( expect_match )); then
            FAILURES+=("[$pair_id] Expected a match but solver reported status=$status value=$value")
            echo "[$pair_id] FAIL - expected match but solver reported status=$status value=$value"
        else
            FAILURES+=("[$pair_id] Expected no match but solver value=$value")
            echo "[$pair_id] FAIL - expected no match but solver value=$value"
        fi
        if [[ $KEEP_SOLUTIONS -eq 0 ]]; then
            rm -f "$solution_file"
        fi
    fi
done <<<"$PAIR_STREAM"

echo
echo "Summary: $PASSED / $TOTAL pairs matched expectations"

if [[ ${#FAILURES[@]} -gt 0 ]]; then
    echo "Failures:"
    for msg in "${FAILURES[@]}"; do
        echo "  - $msg"
    done
    exit 1
fi

exit 0

